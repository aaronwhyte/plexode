v Hella design work

2011.08.26 - 2011.08.31
Graf op JSON format
v JSON schema for ops
v Op reversal fn
v unit test op reversal

2011.08.31 - 2011.09.04
GrafModel basics
v build from ops
v basic queries
v unit tests

2011.09.24 - 2011.09.25
Graf Paste
v descend through clusters, parts, jacks
v grafModel allocates new IDs
v grafModel.paste(grafModel) returns ID map
v unit tests

Refactor "phy" out of sprite constructors
v Wrap Phy methods/fields in Game:
  v rayscan
  v getSpriteBySledgeId - always follows rayscan... Make it automatic?
  v FRICTION
  v invalidateSledgeForSpriteId
x Pass Game in where needed.
  x act()
  x onSpriteHit()
v Remove Phy from concrete sprite types. Only access Game fields.
v Remove Phy from gaam.Sprite

v Vorp Logic: Part 1
v Logic support in Vorp
v Test level (not using transformer or prefabs)


Ved-to-Vorp transformer I
v walls
v one-point wall-huggers
  v assembler
  v button
  v grip

ClipList 2012.03.25 - ...
Whole cliplist will be one Stor object.
Need a replay strategy that does two things:
1: Preserve op numbers
2: Eliminate obsolete ops
After a replay, the remaining ops should have no redundant information.

v add pubsub to Stor events
... 2012.07.03
v write real cross-tab Stor demo
- write OpStor
  - subscribe to invalidations
  - get changes after opdid X
  - demo

- addClip(id, model): inserts in order
- getIds(): returns unsorted ID list
- getClip(id)
- removeClip(id)
- subscribe

key/meta : {metadata}
key/ops : [ops]
metadata includes pointer to first op (0 by default).

How about a more generic collection type that has key-value pairs,
and pubsubs for add and remove,
including a listener thing that maintains a random-access sorted list of keys (in a skiplist or whatev),
and a thing that persists stuff in a Stor.
Also needs a listener for Stor mutations,
and a short-circuit if attempting to add something with an existing key.

Clip interface:
writes:
- add clip(id, model) - error if ID already exists?
- delete clip(id)
reads:
- getClipsIds() - gets ordered array of clip IDs
- getClip(id)
notifications:
- subscribe(fn) - callback can be "invalidate" tickle w no args,
  or full Stor operation (which I just made up) like
  {
    op_type: APPEND,
    obj_name: <clipId>,
    value_index: <0 or 1>, // clips only support set and maybe delete
    values: [graf model ops, including "delete"]
  }

SysClipList instance
- walls
- assembler
- button
- grip

Level 9: clip-based level building
- exercise system clips

Ved-to-Vorp transformer II
- two-point wall-huggers
  - beamsensor
  - door
  - zapper
- free-floaters:
  - block
  - exit
  - portal
  - timer

============== VED UI ============
Clip Sync
How to sync it cross-tab?
Store it as a list of add and remove operations?
[
  {opId: 10, type:put, clipId: 13123113, model: {...}},
  {opId: 11, type:put, clipId: 13432194, model: {...}},
  {opId: 12, type:delete, clipId: 13432194},
]
Each tab listens for appends, reads the op, and executes if it needs that opId.
IDs need to increase, either by time or by read/write. Neither is perfect :-(.

Ved UI API:
- iteration for rendering
- spacial queries
  - mouseover
  - drag selection
  - alter selection
- copy selection to a clipboard
- changes
  - paste from a clipboard
  - link
  - delete
  - undo
- previews
  - linking
  - paste preview
  - dragging parts

Ved model for interactive editing
- write invariant-enforcing concequence computer
  - deleting one portal or wall-endpoint deletes the whole cluster
  - other wall endpoint moves minimum distance to remain coaxial
  - deleting any part deletes all jacks and links and data first
  - deleting last part in a cluster deletes cluster
